/**
 * Centralized Data Store for BDSA Schema Wrangler
 * Manages data synchronization between all components and upstream server
 */

import { loadCSVData as loadCSVDataUtil } from './csvProcessor';
import { loadDsaData as loadDsaDataUtil, syncAllBdsaMetadata, DsaBatchProcessor } from './dsaIntegration';
import {
    DATA_SOURCE_TYPES,
    loadCurrentDataSource,
    saveCurrentDataSource,
    loadDsaConfig,
    saveDsaConfig,
    loadRegexRules,
    loadColumnMapping,
    loadCaseIdMappings,
    loadCaseProtocolMappings,
    saveCaseIdMappings,
    saveCaseProtocolMappings,
    saveColumnMapping,
    saveRegexRules,
    loadGirderToken,
    saveGirderToken
} from './dataSourceManager';

// Global data store
let globalDataStore = {
    // Data state
    currentDataSource: null,
    rawData: [],
    processedData: [],
    columnDefs: [],

    // Configuration
    columnMapping: {
        localStainID: '',
        localCaseId: '',
        localRegionId: ''
    },
    caseIdMappings: {},
    caseProtocolMappings: {},
    regexRules: {},
    dsaConfig: {},
    girderToken: '',

    // UI state
    isLoading: false,
    loadingMessage: '',
    error: null,

    // Synchronization
    lastUpdate: null,
    isDirty: false, // Has unsaved changes
    subscribers: new Set(),
    syncSubscribers: new Set(), // Separate subscribers for sync events only

    // Server integration (future)
    serverConfig: {
        baseUrl: '',
        apiKey: '',
        enabled: false
    },

    // DSA metadata sync state
    syncInProgress: false,
    syncProgress: null,
    lastSyncResults: null,
    batchProcessor: null,
    syncStatus: 'offline', // 'offline', 'syncing', 'synced', 'error'

    // Regex application tracking
    regexApplied: false, // Whether regex has been explicitly applied to current data
    regexGeneratedValues: new Set(), // Track which values were generated by regex
    pendingRegexApplication: false, // Whether there are pending regex applications
    dataSourceConflicts: new Set(), // Track which values have conflicts between source and stored data

    // Centralized modification tracking
    modifiedItems: new Set(), // Track which items have been modified since load
    dataLoadTimestamp: null // When the data was initially loaded
};

/**
 * Data change event types
 */
export const DATA_CHANGE_EVENTS = {
    DATA_LOADED: 'dataLoaded',
    DATA_UPDATED: 'dataUpdated',
    MAPPINGS_CHANGED: 'mappingsChanged',
    PROTOCOLS_CHANGED: 'protocolsChanged',
    COLUMN_MAPPING_CHANGED: 'columnMappingChanged',
    DATA_SOURCE_CHANGED: 'dataSourceChanged',
    DSA_CONFIG_CHANGED: 'dsaConfigChanged',
    LOADING_CHANGED: 'loadingChanged',
    ERROR_OCCURRED: 'errorOccurred',
    SYNC_STATUS_CHANGED: 'syncStatusChanged',
    SYNC_PROGRESS_UPDATED: 'syncProgressUpdated',
    SYNC_COMPLETED: 'syncCompleted',
    SYNC_ERROR: 'syncError',
    SYNC_CANCELLED: 'syncCancelled',
    REGEX_APPLIED: 'regexApplied',
    REGEX_STATUS_CHANGED: 'regexStatusChanged'
};

/**
 * Sync status types
 */
export const SYNC_STATUS = {
    OFFLINE: 'offline',
    SYNCING: 'syncing',
    SYNCED: 'synced',
    ERROR: 'error'
};

/**
 * Subscribe to data store changes
 * @param {Function} callback - Callback function to execute on data changes
 * @param {Array} eventTypes - Array of event types to listen for (optional)
 * @returns {Function} - Unsubscribe function
 */
export const subscribeToDataStore = (callback, eventTypes = null) => {
    const subscriber = {
        callback,
        eventTypes: eventTypes ? new Set(eventTypes) : null
    };

    globalDataStore.subscribers.add(subscriber);

    // Return unsubscribe function
    return () => {
        globalDataStore.subscribers.delete(subscriber);
    };
};

/**
 * Subscribe to sync events only (separate from main data store events)
 * @param {Function} callback - Callback function to execute on sync events
 * @returns {Function} - Unsubscribe function
 */
export const subscribeToSyncEvents = (callback) => {
    const subscriber = { callback };
    globalDataStore.syncSubscribers.add(subscriber);

    // Return unsubscribe function
    return () => {
        globalDataStore.syncSubscribers.delete(subscriber);
    };
};

/**
 * Notify all subscribers of data changes
 * @param {string} eventType - Type of change that occurred
 * @param {Object} data - Changed data
 */
const notifySubscribers = (eventType, data = {}) => {
    globalDataStore.lastUpdate = Date.now();

    globalDataStore.subscribers.forEach(subscriber => {
        if (!subscriber.eventTypes || subscriber.eventTypes.has(eventType)) {
            try {
                subscriber.callback({
                    eventType,
                    data,
                    timestamp: globalDataStore.lastUpdate,
                    dataStore: getDataStoreSnapshot()
                });
            } catch (error) {
                console.error('Error notifying data store subscriber:', error);
            }
        }
    });
};

/**
 * Notify sync subscribers only (separate from main data store notifications)
 * @param {string} eventType - Type of sync event that occurred
 * @param {Object} data - Sync event data
 */
const notifySyncSubscribers = (eventType, data = {}) => {
    const timestamp = Date.now();

    globalDataStore.syncSubscribers.forEach(subscriber => {
        try {
            subscriber.callback({
                eventType,
                data,
                timestamp,
                dataStore: getDataStoreSnapshot()
            });
        } catch (error) {
            console.error('Error notifying sync subscriber:', error);
        }
    });
};

/**
 * Centralized function to update any item in processedData
 * This automatically tracks the modification for sync purposes
 * @param {string} itemId - The ID of the item to update (dsa_id or _id)
 * @param {Object} updates - The updates to apply to the item
 * @param {string} reason - Reason for modification (for debugging)
 * @returns {boolean} - Whether the item was found and updated
 */
export const updateProcessedDataItem = (itemId, updates, reason = 'Item updated') => {
    const item = globalDataStore.processedData.find(item =>
        item.dsa_id === itemId || item._id === itemId
    );

    if (!item) {
        console.warn(`Item not found for update: ${itemId}`);
        return false;
    }

    // Apply the updates
    Object.assign(item, updates);

    // Mark this item as modified in our centralized tracking
    globalDataStore.modifiedItems.add(itemId);

    console.log(`ðŸ”„ UPDATED item ${itemId} - Reason: ${reason}`);
    console.log(`Updates applied:`, updates);
    console.log(`Total modified items: ${globalDataStore.modifiedItems.size}`);

    return true;
};

/**
 * Check if an item has been modified since the initial data load
 * @param {string} itemId - The ID of the item to check
 * @returns {boolean} - Whether the item has been modified
 */
export const isItemModified = (itemId) => {
    return globalDataStore.modifiedItems.has(itemId);
};

/**
 * Get all modified item IDs
 * @returns {Array} - Array of modified item IDs
 */
export const getModifiedItems = () => {
    return Array.from(globalDataStore.modifiedItems);
};

/**
 * Automatically mark an item as locally modified whenever it's updated
 * This should be called whenever any item in processedData is modified
 * @param {Object} item - The item that was modified
 * @param {string} reason - Reason for modification (for debugging)
 */
export const markItemAsModified = (item, reason = 'Item updated') => {
    if (!item) return;

    const timestamp = new Date().toISOString();
    item._localLastModified = timestamp;

    const itemId = item.dsa_id || item._id || 'unknown';
    console.log(`ðŸ”„ AUTO-MARKED item ${itemId} as locally modified at ${timestamp} - Reason: ${reason}`);
};

/**
 * Mark items as locally modified for DSA sync tracking
 * @param {Array|string} itemIdentifiers - Item IDs, case IDs, or slide IDs to mark as modified
 * @param {string} reason - Reason for modification (for debugging)
 */
export const markItemsAsLocallyModified = (itemIdentifiers, reason = 'Unknown change') => {
    const timestamp = new Date().toISOString();
    const identifiers = Array.isArray(itemIdentifiers) ? itemIdentifiers : [itemIdentifiers];

    identifiers.forEach(identifier => {
        globalDataStore.processedData.forEach(item => {
            // Check multiple possible identifier fields
            const itemMatches =
                item.dsa_id === identifier ||
                item._id === identifier ||
                item.BDSA?.localCaseId === identifier ||
                item[globalDataStore.columnMapping.localCaseId] === identifier ||
                item.BDSA?.localStainID === identifier ||
                item[globalDataStore.columnMapping.localStainID] === identifier ||
                item.BDSA?.localRegionId === identifier ||
                item[globalDataStore.columnMapping.localRegionId] === identifier;

            if (itemMatches) {
                item._localLastModified = timestamp;
                console.log(`Marked item ${item.dsa_id || item._id} as locally modified at ${timestamp} - Reason: ${reason}`);
            }
        });
    });
};


/**
 * Get a snapshot of the current data store state
 * @returns {Object} - Current data store state
 */
export const getDataStoreSnapshot = () => {
    return {
        currentDataSource: globalDataStore.currentDataSource,
        rawData: [...globalDataStore.rawData],
        processedData: [...globalDataStore.processedData],
        columnDefs: [...globalDataStore.columnDefs],
        columnMapping: { ...globalDataStore.columnMapping },
        caseIdMappings: { ...globalDataStore.caseIdMappings },
        caseProtocolMappings: { ...globalDataStore.caseProtocolMappings },
        regexRules: { ...globalDataStore.regexRules },
        dsaConfig: { ...globalDataStore.dsaConfig },
        girderToken: globalDataStore.girderToken,
        isLoading: globalDataStore.isLoading,
        lastUpdate: globalDataStore.lastUpdate,
        dataCount: globalDataStore.processedData.length,
        regexApplied: globalDataStore.regexApplied,
        regexGeneratedValues: new Set(globalDataStore.regexGeneratedValues),
        pendingRegexApplication: globalDataStore.pendingRegexApplication,
        dataSourceConflicts: new Set(globalDataStore.dataSourceConflicts)
    };
};

/**
 * Initialize the data store
 */
export const initializeDataStore = async () => {
    try {
        // Load current settings
        globalDataStore.currentDataSource = loadCurrentDataSource();
        globalDataStore.dsaConfig = loadDsaConfig();
        globalDataStore.girderToken = loadGirderToken();

        const config = globalDataStore.currentDataSource === 'dsa' ? globalDataStore.dsaConfig : {};

        // Load data source specific settings
        globalDataStore.columnMapping = loadColumnMapping(globalDataStore.currentDataSource, config);
        globalDataStore.caseIdMappings = loadCaseIdMappings(globalDataStore.currentDataSource);

        // Load protocol mappings and migrate if needed
        const rawProtocolMappings = loadCaseProtocolMappings(globalDataStore.currentDataSource);

        // Load protocols from localStorage
        const stainProtocols = (() => {
            try {
                const stored = localStorage.getItem('bdsa_stain_protocols');
                return stored ? JSON.parse(stored) : [];
            } catch (e) {
                console.error('Error loading stain protocols:', e);
                return [];
            }
        })();

        const regionProtocols = (() => {
            try {
                const stored = localStorage.getItem('bdsa_region_protocols');
                return stored ? JSON.parse(stored) : [];
            } catch (e) {
                console.error('Error loading region protocols:', e);
                return [];
            }
        })();

        // Check if we need to migrate from old format to new segregated format
        const needsMigration = Object.keys(rawProtocolMappings).some(bdsaCaseId => {
            return Object.keys(rawProtocolMappings[bdsaCaseId]).some(slideId => {
                const protocols = rawProtocolMappings[bdsaCaseId][slideId];
                return Array.isArray(protocols) && !protocols.hasOwnProperty('stain');
            });
        });

        if (needsMigration) {
            console.log('Migrating protocol mappings to segregated format...');
            globalDataStore.caseProtocolMappings = migrateProtocolMappings(rawProtocolMappings, stainProtocols, regionProtocols);
            // Save the migrated data
            saveCaseProtocolMappings(globalDataStore.currentDataSource, globalDataStore.caseProtocolMappings);
        } else {
            globalDataStore.caseProtocolMappings = rawProtocolMappings;
        }

        globalDataStore.regexRules = loadRegexRules(globalDataStore.currentDataSource, config);

        console.log('Data store initialized:', getDataStoreSnapshot());

        // Notify subscribers of initialization
        notifySubscribers(DATA_CHANGE_EVENTS.DATA_SOURCE_CHANGED, {
            dataSource: globalDataStore.currentDataSource
        });

        // Auto-load data if configuration is complete
        if (globalDataStore.currentDataSource === DATA_SOURCE_TYPES.CSV) {
            // Always auto-load CSV data
            console.log('Auto-loading CSV data on initialization');
            await loadCurrentData();
        } else if (globalDataStore.currentDataSource === DATA_SOURCE_TYPES.DSA) {
            // Auto-load DSA data if configuration is complete
            if (globalDataStore.dsaConfig?.baseUrl &&
                globalDataStore.dsaConfig?.resourceId &&
                globalDataStore.girderToken) {
                console.log('Auto-loading DSA data on initialization - config is complete');
                await loadCurrentData();
            } else {
                console.log('DSA config incomplete, skipping auto-load:', {
                    hasBaseUrl: !!globalDataStore.dsaConfig?.baseUrl,
                    hasResourceId: !!globalDataStore.dsaConfig?.resourceId,
                    hasToken: !!globalDataStore.girderToken
                });
            }
        }

    } catch (error) {
        console.error('Error initializing data store:', error);
    }
};

/**
 * Load data from the current data source
 * @param {Object} options - Loading options
 * @returns {Promise<Object>} - Loading result
 */
export const loadCurrentData = async (options = {}) => {
    try {
        globalDataStore.isLoading = true;
        notifySubscribers(DATA_CHANGE_EVENTS.DATA_UPDATED, { isLoading: true });

        let result = { success: false, error: 'Unknown error' };

        if (globalDataStore.currentDataSource === DATA_SOURCE_TYPES.CSV) {
            result = await loadCSVDataUtil('/year_2020_dsametadata.csv', null); // Don't apply regex automatically
        } else if (globalDataStore.currentDataSource === DATA_SOURCE_TYPES.DSA) {
            if (!globalDataStore.girderToken) {
                result = {
                    success: false,
                    error: 'Girder token required for DSA data loading'
                };
            } else {
                result = await loadDsaDataUtil(
                    globalDataStore.dsaConfig,
                    globalDataStore.girderToken,
                    null // Don't apply regex automatically
                );
            }
        }

        if (result.success) {
            globalDataStore.rawData = result.data || [];
            globalDataStore.processedData = result.data || [];
            globalDataStore.columnDefs = result.columns || [];

            // Reset tracking when new data is loaded
            globalDataStore.regexApplied = false;
            globalDataStore.regexGeneratedValues.clear();
            globalDataStore.dataSourceConflicts.clear();
            globalDataStore.pendingRegexApplication = hasRegexRulesToApply();

            // Reset modification tracking
            globalDataStore.modifiedItems.clear();
            globalDataStore.dataLoadTimestamp = new Date().toISOString();

            console.log(`Data loaded successfully: ${globalDataStore.processedData.length} rows`);
            console.log(`Modification tracking reset - timestamp: ${globalDataStore.dataLoadTimestamp}`);

            // Notify subscribers of successful data load
            notifySubscribers(DATA_CHANGE_EVENTS.DATA_LOADED, {
                dataSource: globalDataStore.currentDataSource,
                rowCount: globalDataStore.processedData.length,
                columns: globalDataStore.columnDefs
            });

            // Notify about regex status
            notifySubscribers(DATA_CHANGE_EVENTS.REGEX_STATUS_CHANGED, {
                regexApplied: globalDataStore.regexApplied,
                pendingRegexApplication: globalDataStore.pendingRegexApplication
            });
        } else {
            console.error('Error loading data:', result.error);
            globalDataStore.rawData = [];
            globalDataStore.processedData = [];
            globalDataStore.columnDefs = [];
        }

        globalDataStore.isLoading = false;
        notifySubscribers(DATA_CHANGE_EVENTS.DATA_UPDATED, { isLoading: false });

        return result;

    } catch (error) {
        console.error('Error in loadCurrentData:', error);
        globalDataStore.isLoading = false;
        notifySubscribers(DATA_CHANGE_EVENTS.DATA_UPDATED, { isLoading: false });

        return {
            success: false,
            error: error.message
        };
    }
};

/**
 * Update the current data source
 * @param {string} newDataSource - New data source type
 */
export const setCurrentDataSource = (newDataSource) => {
    if (globalDataStore.currentDataSource !== newDataSource) {
        globalDataStore.currentDataSource = newDataSource;

        // Persist the data source change
        saveCurrentDataSource(newDataSource);

        // Clear existing data
        globalDataStore.rawData = [];
        globalDataStore.processedData = [];
        globalDataStore.columnDefs = [];

        // Reload settings for new data source
        const config = newDataSource === 'dsa' ? globalDataStore.dsaConfig : {};
        globalDataStore.columnMapping = loadColumnMapping(newDataSource, config);
        globalDataStore.caseIdMappings = loadCaseIdMappings(newDataSource);
        globalDataStore.caseProtocolMappings = loadCaseProtocolMappings(newDataSource);
        globalDataStore.regexRules = loadRegexRules(newDataSource, config);

        console.log('Data source changed to:', newDataSource);

        notifySubscribers(DATA_CHANGE_EVENTS.DATA_SOURCE_CHANGED, {
            dataSource: newDataSource
        });
    }
};

/**
 * Update column mappings
 * @param {Object} newMapping - New column mapping
 */
export const updateColumnMapping = (newMapping) => {
    globalDataStore.columnMapping = { ...globalDataStore.columnMapping, ...newMapping };

    notifySubscribers(DATA_CHANGE_EVENTS.COLUMN_MAPPING_CHANGED, {
        columnMapping: globalDataStore.columnMapping
    });
};

/**
 * Update case ID mappings
 * @param {Object} newMappings - New case ID mappings
 * @param {Object} options - Update options
 */
export const updateCaseIdMappings = (newMappings, options = {}) => {
    console.log('ðŸ”¥ðŸ”¥ðŸ”¥ updateCaseIdMappings called with:', newMappings);
    const { saveToStorage = true, syncToServer = false } = options;

    // Store the old mappings BEFORE replacing them
    const oldMappings = { ...globalDataStore.caseIdMappings };
    console.log('ðŸ”¥ Old mappings:', oldMappings);

    // Replace the entire mappings object instead of merging to allow deletions
    globalDataStore.caseIdMappings = { ...newMappings };
    globalDataStore.isDirty = true;
    console.log('ðŸ”¥ New mappings set:', globalDataStore.caseIdMappings);

    // Apply case ID mappings to BDSA objects in the data - only update changed items
    const caseIds = Object.keys(newMappings);

    // Only process items that have actually changed
    const changedCaseIds = caseIds.filter(caseId =>
        newMappings[caseId] !== oldMappings[caseId]
    );
    console.log('ðŸ”¥ Changed case IDs:', changedCaseIds);

    changedCaseIds.forEach(originalCaseId => {
        const mappedCaseId = newMappings[originalCaseId];
        console.log(`ðŸ”¥ Processing change: ${originalCaseId} â†’ ${mappedCaseId}`);

        // Find items with this original case ID and update them using the centralized function
        console.log(`ðŸ”¥ Looking for items with caseId: ${originalCaseId}`);
        console.log(`ðŸ”¥ Column mapping for localCaseId: ${globalDataStore.columnMapping.localCaseId}`);

        let foundItems = 0;
        globalDataStore.processedData.forEach((item, index) => {
            const itemCaseId = item[globalDataStore.columnMapping.localCaseId];
            if (itemCaseId === originalCaseId) {
                foundItems++;
                const itemId = item.dsa_id || item._id;
                if (itemId) {
                    console.log(`ðŸ”¥ Found item ${itemId} (index ${index}) with caseId: ${itemCaseId}`);
                    console.log(`ðŸ”¥ Current BDSA.bdsaCaseId: ${item.BDSA?.bdsaCaseId}`);
                    console.log(`ðŸ”¥ Updating to: ${mappedCaseId}`);
                    // Use centralized update function that automatically marks as modified
                    // Update the BDSA.bdsaCaseId field (the mapped BDSA ID)
                    updateProcessedDataItem(itemId, {
                        BDSA: {
                            ...item.BDSA, // Preserve existing BDSA values
                            bdsaCaseId: mappedCaseId  // Store the BDSA Case ID in the correct field
                        }
                    }, `Case ID mapping: ${originalCaseId} â†’ ${mappedCaseId}`);
                }
            }
        });
        console.log(`ðŸ”¥ Total items found with caseId ${originalCaseId}: ${foundItems}`);
    });

    // Mark affected items as modified locally for DSA sync optimization
    const affectedItemIds = [];
    changedCaseIds.forEach(originalCaseId => {
        globalDataStore.processedData.forEach(item => {
            const itemCaseId = item[globalDataStore.columnMapping.localCaseId];
            if (itemCaseId === originalCaseId) {
                const itemId = item.dsa_id || item._id;
                affectedItemIds.push(itemId);
                console.log(`Found item to mark as modified: ${itemId} (case: ${originalCaseId})`);
            }
        });
    });
    console.log(`Marking ${affectedItemIds.length} items as locally modified:`, affectedItemIds);
    markItemsAsLocallyModified(affectedItemIds, 'Case ID mapping change');

    // Save to localStorage
    if (saveToStorage) {
        saveCaseIdMappings(globalDataStore.currentDataSource, globalDataStore.caseIdMappings);
    }

    // Sync to server if enabled
    if (syncToServer && globalDataStore.serverConfig.enabled) {
        syncMappingsToServer('caseIdMappings', globalDataStore.caseIdMappings);
    }

    notifySubscribers(DATA_CHANGE_EVENTS.MAPPINGS_CHANGED, {
        caseIdMappings: globalDataStore.caseIdMappings
    });
};

/**
 * Migrate old protocol mappings format to new segregated format
 * @param {Object} oldMappings - Old protocol mappings format
 * @param {Array} stainProtocols - Available stain protocols
 * @param {Array} regionProtocols - Available region protocols
 * @returns {Object} New segregated protocol mappings
 */
const migrateProtocolMappings = (oldMappings, stainProtocols, regionProtocols) => {
    const newMappings = {};

    Object.keys(oldMappings).forEach(bdsaCaseId => {
        newMappings[bdsaCaseId] = {};
        Object.keys(oldMappings[bdsaCaseId]).forEach(slideId => {
            const protocols = oldMappings[bdsaCaseId][slideId];

            // Separate stain and region protocols
            const stainProtocolIds = protocols.filter(id =>
                stainProtocols.some(p => p.id === id)
            );
            const regionProtocolIds = protocols.filter(id =>
                regionProtocols.some(p => p.id === id)
            );

            newMappings[bdsaCaseId][slideId] = {
                stain: stainProtocolIds,
                region: regionProtocolIds
            };
        });
    });

    return newMappings;
};

/**
 * Update case protocol mappings
 * @param {Object} newMappings - New case protocol mappings
 * @param {Object} options - Update options
 */
export const updateCaseProtocolMappings = (newMappings, options = {}) => {
    const { saveToStorage = true, syncToServer = false } = options;

    globalDataStore.caseProtocolMappings = { ...globalDataStore.caseProtocolMappings, ...newMappings };
    globalDataStore.isDirty = true;

    // Apply protocol mappings to BDSA objects in the data
    console.log('ðŸ” PROTOCOL DEBUG - newMappings structure:', newMappings);
    const slideIds = [];
    Object.keys(newMappings).forEach(caseId => {
        console.log(`ðŸ” PROTOCOL DEBUG - Processing case ${caseId}:`, newMappings[caseId]);
        if (newMappings[caseId] && typeof newMappings[caseId] === 'object') {
            Object.keys(newMappings[caseId]).forEach(slideId => {
                console.log(`ðŸ” PROTOCOL DEBUG - Found slide ID: ${slideId}`);
                slideIds.push(slideId);

                // Find the item and apply protocol mappings to BDSA object
                const item = globalDataStore.processedData.find(item =>
                    item.dsa_id === slideId || item._id === slideId
                );

                if (item) {
                    // Initialize BDSA object if it doesn't exist
                    if (!item.BDSA) {
                        item.BDSA = {};
                    }

                    const protocols = newMappings[caseId][slideId];
                    if (protocols && typeof protocols === 'object') {
                        // Apply stain protocols (protocols.stain already contains protocol names)
                        if (protocols.stain && protocols.stain.length > 0) {
                            item.BDSA.localStainID = protocols.stain;
                            console.log(`Updated BDSA.localStainID for slide ${slideId}:`, item.BDSA.localStainID);
                        }

                        // Apply region protocols (protocols.region already contains protocol names)
                        if (protocols.region && protocols.region.length > 0) {
                            item.BDSA.localRegionId = protocols.region;
                            console.log(`Updated BDSA.localRegionId for slide ${slideId}:`, item.BDSA.localRegionId);
                        }
                    }
                } else {
                    console.warn(`Could not find item for slide ID: ${slideId}`);
                }
            });
        }
    });
    console.log(`ðŸ” PROTOCOL DEBUG - Total slide IDs extracted: ${slideIds.length}`, slideIds);
    if (slideIds.length > 0) {
        console.log(`Marking ${slideIds.length} slides as modified due to protocol changes:`, slideIds);
        markItemsAsLocallyModified(slideIds, 'Protocol mapping change');
    } else {
        console.log('ðŸš¨ PROTOCOL DEBUG - No slide IDs found to mark as modified!');
    }

    // Save to localStorage
    if (saveToStorage) {
        saveCaseProtocolMappings(globalDataStore.currentDataSource, globalDataStore.caseProtocolMappings);
    }

    // Sync to server if enabled
    if (syncToServer && globalDataStore.serverConfig.enabled) {
        syncMappingsToServer('caseProtocolMappings', globalDataStore.caseProtocolMappings);
    }

    notifySubscribers(DATA_CHANGE_EVENTS.PROTOCOLS_CHANGED, {
        caseProtocolMappings: globalDataStore.caseProtocolMappings
    });
};

/**
 * Clear all case protocol mappings (useful for debugging/reset)
 * @param {Object} options - Clear options
 */
export const clearCaseProtocolMappings = (options = {}) => {
    const { saveToStorage = true, syncToServer = false } = options;

    console.log('CLEARING ALL CASE PROTOCOL MAPPINGS - Starting fresh');

    // Clear in-memory mappings
    globalDataStore.caseProtocolMappings = {};
    globalDataStore.isDirty = true;

    // Save empty mappings to localStorage
    if (saveToStorage) {
        saveCaseProtocolMappings(globalDataStore.currentDataSource, {});
    }

    // Sync to server if enabled
    if (syncToServer && globalDataStore.serverConfig.enabled) {
        syncMappingsToServer('caseProtocolMappings', {});
    }

    notifySubscribers(DATA_CHANGE_EVENTS.PROTOCOLS_CHANGED, {
        caseProtocolMappings: {}
    });

    console.log('CLEARED ALL CASE PROTOCOL MAPPINGS - Ready for fresh start');
};

/**
 * Check if there are regex rules that can be applied
 * @returns {boolean} - Whether there are pending regex applications
 */
const hasRegexRulesToApply = () => {
    if (!globalDataStore.regexRules || !globalDataStore.processedData.length) {
        return false;
    }

    // Check if any of the regex rules have patterns defined
    return Object.values(globalDataStore.regexRules).some(rule =>
        rule && rule.pattern && rule.pattern.trim() !== ''
    );
};

/**
 * Apply regex rules to current data explicitly
 * @returns {Object} - Application result
 */
export const applyRegexRules = async () => {
    if (!hasRegexRulesToApply()) {
        return {
            success: false,
            error: 'No regex rules configured or no data to process'
        };
    }

    try {
        globalDataStore.isLoading = true;
        notifySubscribers(DATA_CHANGE_EVENTS.DATA_UPDATED, { isLoading: true });

        // Import regex extractor
        const { applyRegexRules: applyRegexRulesUtil } = await import('./regexExtractor');

        // Apply regex rules to the data, passing column mapping for source data detection
        const updatedData = applyRegexRulesUtil(globalDataStore.processedData, globalDataStore.regexRules, globalDataStore.columnMapping);

        // Mark items with BDSA changes as locally modified for DSA sync
        const modifiedItemIds = [];
        updatedData.forEach((item, index) => {
            if (item._regexExtracted && Object.values(item._regexExtracted).some(extracted => extracted)) {
                const itemId = item.dsa_id || item._id || index;
                modifiedItemIds.push(itemId);
            }
        });
        if (modifiedItemIds.length > 0) {
            markItemsAsLocallyModified(modifiedItemIds, 'Regex rules applied');
        }

        // Track which values were generated by regex and detect data source conflicts
        const newRegexGeneratedValues = new Set();
        const newDataSourceConflicts = new Set();

        updatedData.forEach((item, index) => {
            if (item._regexExtracted) {
                Object.keys(item._regexExtracted).forEach(field => {
                    if (item._regexExtracted[field]) {
                        newRegexGeneratedValues.add(`${index}_${field}`);
                    }
                });
            }

            // Check for data source conflicts
            if (item._dataSource) {
                Object.keys(item._dataSource).forEach(field => {
                    const source = item._dataSource[field];
                    const sourceColumn = globalDataStore.columnMapping[field];

                    // If we have a source column and the value came from regex, check for conflicts
                    if (source === 'regex' && sourceColumn && item[sourceColumn]) {
                        const sourceValue = item[sourceColumn];
                        const storedValue = item.BDSA?.[field];

                        if (sourceValue !== storedValue) {
                            newDataSourceConflicts.add(`${index}_${field}`);
                            console.log(`Data source conflict detected for ${field} at row ${index}: source="${sourceValue}" vs stored="${storedValue}"`);
                        }
                    }
                });
            }
        });

        // Update the data store
        globalDataStore.processedData = updatedData;
        globalDataStore.regexApplied = true;
        globalDataStore.regexGeneratedValues = newRegexGeneratedValues;
        globalDataStore.dataSourceConflicts = newDataSourceConflicts;
        globalDataStore.pendingRegexApplication = false;
        globalDataStore.isDirty = true;

        console.log(`Regex rules applied successfully. Generated ${newRegexGeneratedValues.size} new values, detected ${newDataSourceConflicts.size} data source conflicts.`);

        // Notify subscribers
        notifySubscribers(DATA_CHANGE_EVENTS.REGEX_APPLIED, {
            generatedValuesCount: newRegexGeneratedValues.size,
            conflictCount: newDataSourceConflicts.size,
            regexGeneratedValues: new Set(newRegexGeneratedValues),
            dataSourceConflicts: new Set(newDataSourceConflicts)
        });

        notifySubscribers(DATA_CHANGE_EVENTS.REGEX_STATUS_CHANGED, {
            regexApplied: globalDataStore.regexApplied,
            pendingRegexApplication: globalDataStore.pendingRegexApplication
        });

        notifySubscribers(DATA_CHANGE_EVENTS.DATA_UPDATED, {
            data: globalDataStore.processedData,
            regexApplied: true
        });

        return {
            success: true,
            generatedValuesCount: newRegexGeneratedValues.size
        };

    } catch (error) {
        console.error('Error applying regex rules:', error);
        return {
            success: false,
            error: error.message
        };
    } finally {
        globalDataStore.isLoading = false;
        // Send a final DATA_UPDATED event to clear the loading state
        notifySubscribers(DATA_CHANGE_EVENTS.DATA_UPDATED, {
            isLoading: false,
            data: globalDataStore.processedData
        });
    }
};

/**
 * Update regex rules
 * @param {Object} newRules - New regex rules
 */
export const updateRegexRules = (newRules) => {
    globalDataStore.regexRules = { ...globalDataStore.regexRules, ...newRules };

    // Update pending regex application status
    globalDataStore.pendingRegexApplication = hasRegexRulesToApply();

    // Notify about regex status change
    notifySubscribers(DATA_CHANGE_EVENTS.REGEX_STATUS_CHANGED, {
        regexApplied: globalDataStore.regexApplied,
        pendingRegexApplication: globalDataStore.pendingRegexApplication
    });
};

/**
 * Set Girder token for DSA authentication
 * @param {string} token - Girder token
 */
export const setGirderToken = (token) => {
    globalDataStore.girderToken = token;
    saveGirderToken(token); // Persist to localStorage
    console.log('Girder token updated in data store and saved to localStorage');
};

/**
 * Update DSA configuration
 * @param {Object} newConfig - New DSA configuration
 */
export const updateDsaConfig = (newConfig) => {
    globalDataStore.dsaConfig = { ...globalDataStore.dsaConfig, ...newConfig };

    // Save to localStorage
    saveDsaConfig(globalDataStore.dsaConfig);

    // Notify subscribers
    notifySubscribers(DATA_CHANGE_EVENTS.DSA_CONFIG_CHANGED, {
        dsaConfig: globalDataStore.dsaConfig
    });
};

/**
 * Get current data for a specific component
 * @param {Object} options - Options for data filtering
 * @returns {Object} - Filtered data
 */
export const getCurrentData = (options = {}) => {
    const {
        includeUnmapped = true,
        includeMapped = true,
        filterByStainType = null,
        filterByRegionType = null
    } = options;

    let filteredData = [...globalDataStore.processedData];

    // Apply filters if specified
    if (filterByStainType && globalDataStore.columnMapping.localStainID) {
        filteredData = filteredData.filter(row =>
            row[globalDataStore.columnMapping.localStainID] === filterByStainType
        );
    }

    if (filterByRegionType && globalDataStore.columnMapping.localRegionId) {
        filteredData = filteredData.filter(row =>
            row[globalDataStore.columnMapping.localRegionId] === filterByRegionType
        );
    }

    return {
        data: filteredData,
        columnDefs: globalDataStore.columnDefs,
        columnMapping: globalDataStore.columnMapping,
        caseIdMappings: globalDataStore.caseIdMappings,
        caseProtocolMappings: globalDataStore.caseProtocolMappings,
        totalRows: filteredData.length,
        currentDataSource: globalDataStore.currentDataSource
    };
};

/**
 * Generate unmapped cases from current data
 * @returns {Array} - Array of unmapped cases
 */
export const generateUnmappedCases = () => {
    if (!globalDataStore.processedData.length ||
        (!globalDataStore.columnMapping.localStainID && !globalDataStore.columnMapping.localRegionId)) {
        return [];
    }

    const caseGroups = {};

    globalDataStore.processedData.forEach(row => {
        const localCaseId = row[globalDataStore.columnMapping.localCaseId];
        const localStainId = row[globalDataStore.columnMapping.localStainID];
        const localRegionId = row[globalDataStore.columnMapping.localRegionId];
        const filename = row['name'] || row['dsa_name'];

        const finalFilename = filename || `${localCaseId}_${localStainId || localRegionId}.svs`;

        // Skip if no stain ID or region ID, or no BDSA case ID mapping
        if ((!localStainId && !localRegionId) || !globalDataStore.caseIdMappings[localCaseId]) {
            return;
        }

        const bdsaCaseId = globalDataStore.caseIdMappings[localCaseId];

        if (!caseGroups[bdsaCaseId]) {
            caseGroups[bdsaCaseId] = {
                bdsaId: bdsaCaseId,
                localCaseId: localCaseId,
                slides: []
            };
        }

        // Use dsa_id if available, otherwise fall back to constructed slideId format
        const slideId = row.dsa_id || `${bdsaCaseId}_${finalFilename}`;
        const slideProtocols = globalDataStore.caseProtocolMappings[bdsaCaseId]?.[slideId] || [];

        // Handle both old array format and new segregated format
        let isMapped = false;
        if (Array.isArray(slideProtocols)) {
            // Old format: simple array
            isMapped = slideProtocols.length > 0;
        } else if (slideProtocols && typeof slideProtocols === 'object') {
            // New segregated format: {stain: [], region: []}
            const stainProtocols = slideProtocols.stain || [];
            const regionProtocols = slideProtocols.region || [];
            isMapped = stainProtocols.length > 0 || regionProtocols.length > 0;
        } else {
            // Fallback for any other format
            isMapped = Boolean(slideProtocols);
        }

        caseGroups[bdsaCaseId].slides.push({
            id: slideId,
            stainType: localStainId,
            regionType: localRegionId,
            status: isMapped ? 'mapped' : 'unmapped',
            localStainId: localStainId,
            localRegionId: localRegionId,
            filename: finalFilename
        });
    });

    return Object.values(caseGroups).filter(caseData =>
        caseData.slides.some(slide => slide.status === 'unmapped')
    );
};

/**
 * Server Integration Functions (for future upstream server connection)
 */

/**
 * Configure server connection
 * @param {Object} config - Server configuration
 */
export const configureServer = (config) => {
    globalDataStore.serverConfig = { ...globalDataStore.serverConfig, ...config };

    if (config.enabled) {
        globalDataStore.syncStatus = SYNC_STATUS.OFFLINE;
        notifySubscribers(DATA_CHANGE_EVENTS.SYNC_STATUS_CHANGED, {
            syncStatus: globalDataStore.syncStatus
        });
    }
};

/**
 * Sync mappings to server
 * @param {string} mappingType - Type of mapping to sync
 * @param {Object} data - Data to sync
 */
const syncMappingsToServer = async (mappingType, data) => {
    if (!globalDataStore.serverConfig.enabled) return;

    try {
        globalDataStore.syncStatus = SYNC_STATUS.SYNCING;
        notifySubscribers(DATA_CHANGE_EVENTS.SYNC_STATUS_CHANGED, {
            syncStatus: globalDataStore.syncStatus
        });

        // TODO: Implement actual server sync
        const response = await fetch(`${globalDataStore.serverConfig.baseUrl}/api/mappings/${mappingType}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${globalDataStore.serverConfig.apiKey}`
            },
            body: JSON.stringify({
                dataSource: globalDataStore.currentDataSource,
                mappings: data,
                timestamp: Date.now()
            })
        });

        if (response.ok) {
            globalDataStore.syncStatus = SYNC_STATUS.SYNCED;
            globalDataStore.isDirty = false;
        } else {
            throw new Error(`Server sync failed: ${response.status}`);
        }

    } catch (error) {
        console.error('Server sync error:', error);
        globalDataStore.syncStatus = SYNC_STATUS.ERROR;

        notifySubscribers(DATA_CHANGE_EVENTS.ERROR_OCCURRED, {
            error: error.message,
            context: 'server_sync'
        });
    }

    notifySubscribers(DATA_CHANGE_EVENTS.SYNC_STATUS_CHANGED, {
        syncStatus: globalDataStore.syncStatus
    });
};

/**
 * Load mappings from server
 * @returns {Promise<boolean>} - Success status
 */
export const loadMappingsFromServer = async () => {
    if (!globalDataStore.serverConfig.enabled) return false;

    try {
        globalDataStore.syncStatus = SYNC_STATUS.SYNCING;
        notifySubscribers(DATA_CHANGE_EVENTS.SYNC_STATUS_CHANGED, {
            syncStatus: globalDataStore.syncStatus
        });

        // TODO: Implement actual server loading
        const response = await fetch(`${globalDataStore.serverConfig.baseUrl}/api/mappings`, {
            headers: {
                'Authorization': `Bearer ${globalDataStore.serverConfig.apiKey}`
            }
        });

        if (response.ok) {
            const serverData = await response.json();

            // Update local data with server data
            if (serverData.caseIdMappings) {
                globalDataStore.caseIdMappings = serverData.caseIdMappings;
            }
            if (serverData.caseProtocolMappings) {
                globalDataStore.caseProtocolMappings = serverData.caseProtocolMappings;
            }

            globalDataStore.syncStatus = SYNC_STATUS.SYNCED;
            globalDataStore.isDirty = false;

            // Notify subscribers of updated data
            notifySubscribers(DATA_CHANGE_EVENTS.MAPPINGS_CHANGED, {
                caseIdMappings: globalDataStore.caseIdMappings
            });
            notifySubscribers(DATA_CHANGE_EVENTS.PROTOCOLS_CHANGED, {
                caseProtocolMappings: globalDataStore.caseProtocolMappings
            });

            return true;
        } else {
            throw new Error(`Server load failed: ${response.status}`);
        }

    } catch (error) {
        console.error('Server load error:', error);
        globalDataStore.syncStatus = SYNC_STATUS.ERROR;

        notifySubscribers(DATA_CHANGE_EVENTS.ERROR_OCCURRED, {
            error: error.message,
            context: 'server_load'
        });

        return false;
    } finally {
        notifySubscribers(DATA_CHANGE_EVENTS.SYNC_STATUS_CHANGED, {
            syncStatus: globalDataStore.syncStatus
        });
    }
};

/**
 * Force sync all data to server
 * @returns {Promise<boolean>} - Success status
 */
export const syncAllToServer = async () => {
    if (!globalDataStore.serverConfig.enabled) return false;

    try {
        await syncMappingsToServer('caseIdMappings', globalDataStore.caseIdMappings);
        await syncMappingsToServer('caseProtocolMappings', globalDataStore.caseProtocolMappings);
        return true;
    } catch (error) {
        console.error('Full sync error:', error);
        return false;
    }
};

// Initialize the data store when the module loads
initializeDataStore();

/**
 * Syncs local BDSA metadata to DSA server
 * @param {Function} progressCallback - Optional progress callback
 * @returns {Promise<Object>} Sync results
 */
export const syncBdsaMetadataToServer = async (progressCallback = null) => {
    if (globalDataStore.currentDataSource !== DATA_SOURCE_TYPES.DSA) {
        throw new Error('DSA sync is only available when using DSA data source');
    }

    if (!globalDataStore.girderToken || !globalDataStore.dsaConfig.baseUrl) {
        throw new Error('DSA authentication or configuration missing');
    }

    if (globalDataStore.syncInProgress) {
        throw new Error('Sync already in progress');
    }

    try {
        // Set sync in progress
        globalDataStore.syncInProgress = true;
        globalDataStore.syncStatus = 'syncing';
        globalDataStore.syncProgress = { processed: 0, total: globalDataStore.processedData.length };

        notifySubscribers({
            eventType: DATA_CHANGE_EVENTS.SYNC_STATUS_CHANGED,
            dataStore: getDataStoreSnapshot()
        });

        // Start sync process
        const results = await syncAllBdsaMetadata(
            globalDataStore.dsaConfig.baseUrl,
            globalDataStore.processedData,
            globalDataStore.girderToken,
            globalDataStore.columnMapping,
            (progress) => {
                globalDataStore.syncProgress = progress;
                if (progressCallback) {
                    progressCallback(progress);
                }
                // Notify only sync subscribers (not main data store subscribers)
                notifySyncSubscribers(DATA_CHANGE_EVENTS.SYNC_PROGRESS_UPDATED, progress);
            }
        );

        // Store results
        globalDataStore.lastSyncResults = results;
        globalDataStore.syncStatus = results.completed ? 'synced' : 'error';

        console.log('DSA metadata sync completed:', results);

        // Notify only sync subscribers about completion
        notifySyncSubscribers(DATA_CHANGE_EVENTS.SYNC_COMPLETED, results);

        return results;

    } catch (error) {
        console.error('DSA metadata sync failed:', error);
        globalDataStore.syncStatus = 'error';
        globalDataStore.lastSyncResults = {
            completed: false,
            error: error.message,
            totalItems: globalDataStore.processedData.length,
            processed: 0,
            success: 0,
            errors: 1
        };

        notifySubscribers({
            eventType: DATA_CHANGE_EVENTS.SYNC_ERROR,
            dataStore: getDataStoreSnapshot()
        });

        throw error;
    } finally {
        globalDataStore.syncInProgress = false;
        globalDataStore.batchProcessor = null;
    }
};

/**
 * Cancels ongoing DSA metadata sync
 */
export const cancelDsaMetadataSync = () => {
    if (globalDataStore.batchProcessor) {
        globalDataStore.batchProcessor.cancel();
        globalDataStore.syncStatus = 'offline';
        globalDataStore.syncInProgress = false;

        notifySubscribers({
            eventType: DATA_CHANGE_EVENTS.SYNC_CANCELLED,
            dataStore: getDataStoreSnapshot()
        });
    }
};

/**
 * Gets the current sync status and progress
 * @returns {Object} Sync status information
 */
export const getSyncStatus = () => {
    return {
        inProgress: globalDataStore.syncInProgress,
        status: globalDataStore.syncStatus,
        progress: globalDataStore.syncProgress,
        lastResults: globalDataStore.lastSyncResults
    };
};

export {
    DATA_SOURCE_TYPES
};

export default {
    subscribeToDataStore,
    getDataStoreSnapshot,
    initializeDataStore,
    loadCurrentData,
    setCurrentDataSource,
    updateColumnMapping,
    updateCaseIdMappings,
    updateCaseProtocolMappings,
    clearCaseProtocolMappings,
    updateRegexRules,
    applyRegexRules,
    setGirderToken,
    updateDsaConfig,
    getCurrentData,
    generateUnmappedCases,
    configureServer,
    loadMappingsFromServer,
    syncAllToServer,
    syncBdsaMetadataToServer,
    cancelDsaMetadataSync,
    getSyncStatus,
    markItemsAsLocallyModified,
    markItemAsModified,
    DATA_CHANGE_EVENTS,
    SYNC_STATUS
};
